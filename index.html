<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Break the Swipe</title>
  <style>
    @font-face {
        font-family: 'establishRetrosansOTF';
        src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2112@1.0/establishRetrosansOTF.woff') format('woff');
        font-weight: normal;
        font-style: normal;
    }

    body {
      margin: 0;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    .blind {
      position: absolute;
      background: white;
      color: black;
      font-family: Arial, sans-serif;
      font-size: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    #currentTimeLabel {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: grey;
      font-size: 50px;
      text-align: center;
      z-index: -1;
    }

    .message {
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      text-align: center;
      margin-top: 120px;
      line-height: 1.5;
      z-index: -1;
      position: absolute;
      top: 20px;
    }

    .swipe, .break {
      opacity: 0;
      transition: opacity 1s ease-in-out; /* ì „í™˜ ì‹œê°„ ì¡°ì ˆ */
    }

    .show {
      opacity: 1;
    }

    .intro {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background-color: black;
      color: white;
      display: flex;
      flex-direction: column; /* ì„¸ë¡œ ë°©í–¥ìœ¼ë¡œ ë°°ì¹˜ */
      justify-content: center;
      align-items: center;
      z-index: 9999; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œ */
      transition: opacity 0.5s ease-in-out; /* íˆ¬ëª…ë„ ë³€í™” ì• ë‹ˆë©”ì´ì…˜ */
    }

    .title-text {
      font-size: 1.4rem; /* h1 íƒœê·¸ì˜ ê¸€ì í¬ê¸°ë¥¼ 3remìœ¼ë¡œ ì„¤ì • */
      line-height: 1.6;
      align-items: center;
    }

    .content-text {
      font-size: 1.0rem; /* p íƒœê·¸ì˜ ê¸€ì í¬ê¸°ë¥¼ 1.5remìœ¼ë¡œ ì„¤ì • */
      color: grey;
    }

  </style>
</head>
<body>

  <div class="intro">
    <div class="title">
      <h1 class="title-text">ìš°ë¦¬ëŠ” ëŠì„ì—†ì´ ìŠ¤ì™€ì´í”„í•˜ë©° <br>
       &nbsp;&nbsp;&nbsp;ë¬´ì—‡ì„ ì–»ê³  ë¬´ì—‡ì„ ìƒì„ê¹Œ?</h1>
    </div>
    <p class="content-text" id="typing-text">ì–»ê¸° ìœ„í•´ ë©ˆì¶°ì•¼ í•  íŒŒê´´ì  í–‰ìœ„ì— ëŒ€í•˜ì—¬</p>
  </div>


  <div class="message">
    <span class="swipe">SWIPE</span> if you're curious<br>
    <span class="break show">BREAK</span> if you want more
  </div>

  <canvas id="clockCanvas"></canvas>
  

  <script type="module">

    const typingText = document.getElementById('typing-text');
    const textArray = typingText.textContent.split('');
    typingText.textContent = '';

    let charIndex = 0;

    function type() {
      typingText.textContent += textArray[charIndex];
      charIndex++;
      if (charIndex < textArray.length) {
        setTimeout(type, 100); // 100msë§ˆë‹¤ ë‹¤ìŒ ê¸€ì ì…ë ¥
      }
    }

    type();

    setTimeout(() => {
      const intro = document.querySelector('.intro');
      intro.style.opacity = 0;
      setTimeout(() => {
        intro.style.display = 'none';
      }, 500); // 0.5ì´ˆ í›„ì— display: none; ì„¤ì •
    }, 4000); // 3ì´ˆ í›„ì— opacityë¥¼ 0ìœ¼ë¡œ ë³€ê²½
   

    const canvas = document.getElementById('clockCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const swipe = document.querySelector('.swipe');
    const breakWord = document.querySelector('.break');

    setInterval(() => {
      swipe.classList.toggle('show');
      breakWord.classList.toggle('show');
    }, 3000); // 1ì´ˆë§ˆë‹¤ í´ë˜ìŠ¤ í† ê¸€

    const textSize = 140;
    const blockSize = 20;
    const fontName = 'establishRetrosansOTF';
    const font = `${textSize}px ${fontName}`;

    let trails = [];
    let blinds = [];
    window.blinds = blinds;
    let blindSpeed = 7;
    let speedIncrement = 0.0065;
    let blocks = [];
    let disabledAreas = [];
    let fragments = [];
    let trailBuffer = 10;
    const maxTrailBuffer = 30;
    const bufferIncrement = 0.05;
    let isSwiping = false; // ìŠ¤ì™€ì´í”„ ìƒíƒœë¥¼ ì¶”ì 


// ì œëª©ê³¼ ì‚¬ì§„ ë°ì´í„° ì¤€ë¹„
const titleImagePairs = [
  { title: "'ë‰´ì§„ìŠ¤' ë©¤ë²„ë“¤ì´ ì„ íƒí•œ ìƒˆë¡œìš´ í™œë™ëª…", image: "1.png" },
  { title: "20ëŒ€ ì²«ì°¨ ì‚´ ë•Œ ì²´ê° ã…‹ã…‹ã…‹", image: "2.png" },
  { title: "ì§€ê¸ˆë³´ë‹ˆ ì†Œë¦„ ë‹ëŠ” ì„ë‹¬ ì „ ê¹€ë¯¼ì„, ìœ¤ì„ì—´ ë¹„ìƒê³„ì—„ ì‚¬íƒœ ì •í™•íˆ ì˜ˆì¸¡?!(feat.ì…ë²Œêµ¬ ê¹€ìš©í˜„)", image: "3.png" },
  { title: "'ë„ˆ ëˆ„êµ¬ ê¼¬ì…” ë³¸ ì  ì—†ì§€?'â€¦ë¡œì œ(ROSÃ‰) X ë¸Œë£¨ë…¸ë§ˆìŠ¤(Bruno Mars) ë¹„í•˜ì¸ë“œ ì° #JTBC", image: "4.png"},
  { title: "ì¥ì¬í˜„ ê°ë…ì´ ê¹€ê³ ì€ì—ê²Œ í•œ ë§ (ê°ë™ì£¼ì˜) #ì²­ë£¡ì˜í™”ìƒ", image: "5.png"},
  { title: "ê³¼ìì‚¬ëŸ¬ ë‚˜ì™”ë‹¤ê°€ ê³„ì—„êµ°í•œí…Œ ë§‰í˜”ë˜ ì‹œë¯¼ ì¸í„°ë·° ã…‹ã…‹", image: "6.png"},
  { title: "í•´ì™¸ì—ì„œ ìš•ë¨¹ê³  ìˆë‹¤ëŠ” ì˜¤ì§•ì–´ê²Œì„2 ì„­ì™¸ .. ì´ê²Œ ë§ì•„?", image: "7.png"},
  { title: "ì¸ë¥˜ ìµœê³ ì˜ ë‚œë°© ë°©ì‹ì´ë¼ í‰ê°€ë°›ëŠ” ìš°ë¦¬ë‚˜ë¼ ì›ì¡° ì˜¨ëŒ í´ë¼ìŠ¤", image: "8.png"},
  { title: "íŠ¸ëŸ¼í”„ì—ê²Œ ëŒì§êµ¬ë¡œ íŒ©í­ë‚ ë¦¬ëŠ” í•œêµ­ê³„ í•˜ë²„ë“œ í•™ìƒ", image: "9.png"},
  { title: "êµ°ê³ êµ¬ë§ˆ ì¥ì‚¬í•˜ëŠ” ê³ ì–‘ì´", image: "10.png"},
  { title: "ì•„ì´ ìì¡´ê° ì§€í‚¨ ë¶€ëª¨ì˜ í•œë§ˆë”” #ì¸ìƒì¡°ì–¸ #ëª…ì–¸ #ë™ê¸°ë¶€ì—¬ #ìê¸°ê³„ë°œ", image: "11.png"},
  { title: "ì¤‘êµ­ ìµœì•…ì˜ í˜¸í…”ë·° ì»´í”Œë ˆì¸", image: "12.png"},
  { title: "ìš°ë¦¬ê°€ í¸ê²¬ì„ ë²„ë ¤ì•¼ í•˜ëŠ” ì´ìœ  ğŸ˜² #fish #birds", image: "13.png"},
  { title: "ì•„ì´ëŒ ì¶œì‹  ì˜¤ë””ì…˜ ì°¸ê°€ìì˜ ë¯¸ì¹œ ê³ ìŒì— ë‚œë¦¬ ë‚œ ì‹¬ì‚¬ìœ„ì› ë°˜ì‘ã„·ã„· ê¹€ìƒë¯¼ - YOU", image: "14.png"},
  { title: "ìˆ˜ë ¹ ë™ì§€! ë‚¨ì¡°ì„  ìƒˆë¡œìš´ ì†Œì‹ì…ë„¤ë‹¤!", image: "15.png"},
  { title: "LOVEë¥¼ ë§ˆêµ¬ë§ˆêµ¬ ë°”ê¾¼ ì „ì„¤ì˜ í•œì–‘ëŒ€ ë¹ŒëŸ°ë“¤", image: "16.png"},
  { title: "ë„˜ì§€ ë§ì•„ì•¼ í•  ë‘ ê°œì˜ ì„ ", image: "17.png"},
  { title: "ê±°ë¦¬ì—ì„œ ë‚˜ì˜¨ ë ˆì „ë“œ ìºë¡¤ ì—°ì£¼", image: "18.png"},
  { title: "ê°±ìŠ¤í„° ë³´ìŠ¤ê°€ ë˜ë²„ë¦° ë¦¬íŠ¸ë¦¬ë²„", image: "19.png"},
  { title: "ì˜í™”ë³´ë‹¤ ë” ì˜í™”ê°™ì€ ì¼ì´ ë²Œì–´ì§„ íƒì‹œê¸°ì‚¬ #íƒì‹œê¸°ì‚¬ #ê²½ì°°ê´€ #ì‹¤ì œìƒí™©", image: "20.png"},
  { title: "k-pop ê·¼ë³¸êµ­ê°€ì˜ ì‹œìœ„ í´ë¼ì“° : ì‘ì›ë´‰ê³¼ ë–¼ì°½", image: "21.png"},
  { title: "ì§ì¥ì¸ 99%ê°€ ëª¨ë¥´ëŠ” AI í™œìš©ë²•", image: "22.png"},
  { title: "ì¸ê°„ë³µì‚¬ê¸°ë¡œ ëª¨ì¡°ë¦¬ ëª°ë˜ì¹´ë©”ë¼ë¥¼ í•˜ëŠ” ê°•ì£¼ì€ #ì“°ë³µë§Œ", image: "23.png"},
  { title: "ì§€ì ¤ ë‹ë‹ ë‚˜ë ì˜ ìì¡´ì‹¬ì´ ê±¸ë¦° í•œêµ­ë§ ë°°í‹€", image: "24.png"},
  { title: "ì•…ëª½ ê°™ì€ ìˆœê°„ì„ ë§ˆì£¼í•œ ë¬´ëŒ€ ìœ„ í”¼ì•„ë‹ˆìŠ¤íŠ¸", image: "25.png"},
  // ... ì´ 25ìŒ
];






// ë¸”ë¼ì¸ë“œ ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
function createBlind(x, y, width, height, dx, dy, type = "vertical") {
  const randomPair = titleImagePairs[Math.floor(Math.random() * titleImagePairs.length)];
  blinds.push({
    x,
    y,
    width,
    height,
    dx,
    dy,
    type,
    title: randomPair.title,
    image: randomPair.image,
    imgLoaded: false, // ì´ë¯¸ì§€ ë¡œë“œ ìƒíƒœ
    imgElement: null, // ì´ë¯¸ì§€ ê°ì²´ ì €ì¥
  });

  // ì´ë¯¸ì§€ ê°ì²´ ìƒì„± ë° ë¡œë“œ
  const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = randomPair.image;
    img.onload = () => {
      const blind = blinds.find((b) => b.image === randomPair.image);
      if (blind) {
        blind.imgLoaded = true;
        blind.imgElement = img;
      }
    };
    
}


createBlind(0, -canvas.height * 0.9, canvas.width, canvas.height, 0, 0);



    // updateBlinds í•¨ìˆ˜ ìˆ˜ì •
  function updateBlinds() {
  blinds.forEach(async (blind, index) => {


    // ë¸”ë¼ì¸ë“œ ì´ë™
    blind.x += blind.dx;
    blind.y += blind.dy;

      // í™”ë©´ ê²½ê³„ë¥¼ ë²—ì–´ë‚œ ë¸”ë¼ì¸ë“œ ê°ì§€
    const isOutOfBounds =
      blind.x + blind.width < 0 || // ì™¼ìª½ìœ¼ë¡œ ë²—ì–´ë‚¨
      blind.x > canvas.width || // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë²—ì–´ë‚¨
      blind.y + blind.height < 0 || // ìœ„ë¡œ ë²—ì–´ë‚¨
      blind.y > canvas.height; // ì•„ë˜ë¡œ ë²—ì–´ë‚¨

    if (isOutOfBounds) {
      // ë¸”ë¼ì¸ë“œ ì œê±°
      blinds.splice(index, 1);

      // ìƒˆ ë¸”ë¼ì¸ë“œ ìƒì„±
      const randomDirection = [
      { x: 0, y: -canvas.height * 0.9, dx: 0, dy: 0, type: "vertical" },
      { x: 0, y: canvas.height * 0.9, dx: 0, dy: 0, type: "vertical" },
      { x: -canvas.width * 0.9, y: 0, dx: 0, dy: 0, type: "horizontal" },
      { x: canvas.width * 0.9, y: 0, dx: 0, dy: 0, type: "horizontal" },
    ][Math.floor(Math.random() * 4)];

    createBlind(
      randomDirection.x,
      randomDirection.y,
      canvas.width,
      canvas.height,
      randomDirection.dx,
      randomDirection.dy,
      randomDirection.type
    );0
    }



    // ì‹œê°„ í…ìŠ¤íŠ¸ì™€ ì¶©ëŒ ê°ì§€
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, "0");
    const minutes = String(now.getMinutes()).padStart(2, "0");
    const seconds = String(now.getSeconds()).padStart(2, "0");
    const milliseconds = String(now.getMilliseconds()).padStart(3, "0");
    const timeText = `${hours}:${minutes}:${seconds}:${milliseconds}`;

    const textWidth = ctx.measureText(timeText).width;
    const timeArea = {
      x: canvas.width / 2 - textWidth / 2,
      y: canvas.height / 2 - textSize / 2,
      width: textWidth,
      height: textSize,
    };

    // ë¸”ë¼ì¸ë“œì™€ ì‹œê°„ í…ìŠ¤íŠ¸ ì¶©ëŒ ì—¬ë¶€ í™•ì¸
    const isColliding =
      blind.x < timeArea.x + timeArea.width &&
      blind.x + blind.width > timeArea.x &&
      blind.y < timeArea.y + timeArea.height &&
      blind.y + blind.height > timeArea.y;

    if (isColliding) {

      if (!isClockVisible) {
        isClockVisible = true; // ì‹œê³„ë¥¼ í‘œì‹œ

        if (!hasTriggeredFragmentation) {
            triggerInitialFragmentation(); // ì´ˆê¸° íŒŒí¸í™” ì‹¤í–‰
            hasTriggeredFragmentation = true; // í•œ ë²ˆë§Œ ì‹¤í–‰
        }

    }

      // ì‹œê°„ ë¸”ë¡ íŒŒí¸í™”
      blocks.forEach((block, blockIndex) => {
        const isBlockColliding =
          block.x + block.width > blind.x &&
          block.x < blind.x + blind.width &&
          block.y + block.height > blind.y &&
          block.y < blind.y + blind.height;

        if (isBlockColliding) {
          const fragmentCount = 4;
          for (let i = 0; i < fragmentCount; i++) {
            const dx = (Math.random() - 0.5) * 10;
            const dy = (Math.random() - 0.5) * 10;
            fragments.push({
              x: block.x,
              y: block.y,
              dx,
              dy,
              size: block.width / 2,
              opacity: 1,
            });
          }
          blocks.splice(blockIndex, 1);
        }
      });

      // ë¸”ë¼ì¸ë“œ íŒŒí¸í™”
      const blindFragmentCount = 24;
        for (let i = 0; i < blindFragmentCount; i++) {
            const dx = (Math.random() - 0.5) * 15;
            const dy = (Math.random() - 0.5) * 15;

            // ì´ë¯¸ì§€ ì¡°ê° í¬ê¸° ê³„ì‚° (0.5ë°°ë¡œ ì¤„ì„)
            const fragmentWidth = (blind.width / 6) * 0.5; // 6x4 ì¡°ê°, 0.5ë°° ì¶•ì†Œ
            const fragmentHeight = (blind.height / 4) * 0.5;

            const imageFragment = blind.imgLoaded && blind.imgElement ? {
                imgElement: blind.imgElement, // ì´ë¯¸ì§€ë¥¼ ì§ì ‘ ì €ì¥
                sx: (i % 6) * fragmentWidth * 2, // 0.5ë°°ë¡œ ì¶•ì†Œí–ˆìœ¼ë¯€ë¡œ ì›ë³¸ì—ì„œ 2ë°° í¬ê¸°ë¡œ ì°¸ì¡°
                sy: Math.floor(i / 6) * fragmentHeight * 2,
                sWidth: fragmentWidth * 2,
                sHeight: fragmentHeight * 2,
            } : null;

            fragments.push({
                x: blind.x + (i % 6) * fragmentWidth,
                y: blind.y + Math.floor(i / 6) * fragmentHeight,
                dx,
                dy,
                size: Math.min(fragmentWidth, fragmentHeight),
                opacity: 1,
                imageFragment,
            });
        }



      // ì¶©ëŒí•œ ë¸”ë¼ì¸ë“œ ì œê±°
      blinds.splice(index, 1);

      // ìƒˆ ë¸”ë¼ì¸ë“œ ìƒì„±
      const randomDirection = [
  { x: 0, y: -canvas.height * 0.9, dx: 0, dy: 0, type: "vertical" },
  { x: 0, y: canvas.height * 0.9, dx: 0, dy: 0, type: "vertical" },
  { x: -canvas.width * 0.9, y: 0, dx: 0, dy: 0, type: "horizontal" },
  { x: canvas.width * 0.9, y: 0, dx: 0, dy: 0, type: "horizontal" },
][Math.floor(Math.random() * 4)];

createBlind(
  randomDirection.x,
  randomDirection.y,
  canvas.width,
  canvas.height,
  randomDirection.dx,
  randomDirection.dy,
  randomDirection.type
);0

    }

    // í™”ì‚´í‘œë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
     function drawArrow(ctx, x, y, angle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle); // ë°©í–¥ ì„¤ì •
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-15, -12); // ì™¼ìª½ ì„ 
      ctx.lineTo(15, -12);  // ì˜¤ë¥¸ìª½ ì„ 
      ctx.closePath();
      ctx.fillStyle = "black";
      ctx.fill();
      ctx.restore();
    }


    // ë¸”ë¼ì¸ë“œ ë Œë”ë§
    ctx.fillStyle = 'white';
    ctx.fillRect(blind.x, blind.y, blind.width, blind.height);




    // í™”ì‚´í‘œ ë Œë”ë§
    if (blind.type === "vertical") {
    if (blind.y < 0) {
      drawArrow(ctx, blind.x + blind.width / 2, blind.y + blind.height * 0.99, 0);
    } else {
      drawArrow(ctx, blind.x + blind.width / 2, blind.y + blind.height * 0.01, -Math.PI);
    }
  } else if (blind.type === "horizontal") {
    if (blind.x < 0) {
      drawArrow(ctx, blind.x + blind.width * 0.995, blind.y + blind.height / 2, -Math.PI / 2);
    } else {
      drawArrow(ctx, blind.x + blind.width * 0.005, blind.y + blind.height / 2, Math.PI / 2);
    }
  }


// ì´ë¯¸ì§€ ë Œë”ë§
if (blind.imgLoaded && blind.imgElement) {
  const img = blind.imgElement;
  const aspectRatio = img.width / img.height; // ì´ë¯¸ì§€ ë¹„ìœ¨

  let drawWidth, drawHeight, drawX, drawY;

  // ì´ë¯¸ì§€ í¬ê¸° ê³„ì‚° (ë¹„ìœ¨ ìœ ì§€)
  if (aspectRatio > blind.width / blind.height) {
    drawWidth = blind.width*0.2;
    drawHeight = drawWidth / aspectRatio;
  } else {
    drawHeight = blind.height*0.8;
    drawWidth = drawHeight * aspectRatio;
  }

  // ë¸”ë¼ì¸ë“œ ìœ í˜•ë³„ ì´ë¯¸ì§€ ìœ„ì¹˜ ê³„ì‚°
  if (blind.type === "vertical" && blind.y > 0) {
    // ìƒë‹¨ ë¸”ë¼ì¸ë“œ
    drawX = blind.x + (blind.width - drawWidth) / 2;
    drawY = blind.y + (blind.height * 0.1);
  } else if (blind.type === "vertical" && blind.y < 0) {
    // í•˜ë‹¨ ë¸”ë¼ì¸ë“œ
    drawX = blind.x + (blind.width - drawWidth) / 2;
    drawY = blind.y + (blind.height * 0.1);
  } else if (blind.type === "horizontal" && blind.x < 0) {
    // ì¢Œì¸¡ ë¸”ë¼ì¸ë“œ
    drawX = blind.x + (blind.width - drawWidth) - blind.width*0.085; // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë” ì´ë™
    drawY = blind.y + (blind.height - drawHeight) / 2;
  } else if (blind.type === "horizontal" && blind.x > 0) {
    // ìš°ì¸¡ ë¸”ë¼ì¸ë“œ
    drawX = blind.x + (blind.width * 0.085) ; // ì™¼ìª½ìœ¼ë¡œ ë” ì´ë™
    drawY = blind.y + (blind.height - drawHeight) / 2;
  } else {
    // ê¸°ë³¸: ì¤‘ì•™ ì •ë ¬
    drawX = blind.x + (blind.width - drawWidth) / 2;
    drawY = blind.y + (blind.height - drawHeight) / 2;
  }


  // ì´ë¯¸ì§€ ë Œë”ë§
  ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
}








    // ë¸”ë¼ì¸ë“œ í…ìŠ¤íŠ¸ ë Œë”ë§
    const text = blind.title;
    ctx.save(); // ìº”ë²„ìŠ¤ ìƒíƒœ ì €ì¥

     if (blind.type === "vertical") {
      // ìƒí•˜ ë¸”ë¼ì¸ë“œ (ìˆ˜ì§)
      if (blind.y < 0) {
        // ìƒë‹¨ ë¸”ë¼ì¸ë“œ: í…ìŠ¤íŠ¸ëŠ” ìƒë‹¨ 10% ì˜ì—­ì— ìˆ˜í‰ìœ¼ë¡œ í‘œì‹œ
        ctx.translate(blind.x + blind.width / 2, blind.y + blind.height * 0.945);
      } else {
        // í•˜ë‹¨ ë¸”ë¼ì¸ë“œ: í…ìŠ¤íŠ¸ëŠ” ìƒë‹¨ 10% ì˜ì—­ì— ìˆ˜í‰ìœ¼ë¡œ í‘œì‹œ
        ctx.translate(blind.x + blind.width / 2, blind.y + blind.height * 0.055);
      }
    } else if (blind.type === "horizontal") {
      // ì¢Œìš° ë¸”ë¼ì¸ë“œ (ìˆ˜í‰)
      if (blind.x < 0) {
        // ì¢Œì¸¡ ë¸”ë¼ì¸ë“œ: í…ìŠ¤íŠ¸ë¥¼ 90ë„ íšŒì „
        ctx.translate(blind.x + blind.width * 0.95, blind.y + blind.height / 2);
        ctx.rotate(-Math.PI / 2);
      } else {
        // ìš°ì¸¡ ë¸”ë¼ì¸ë“œ: í…ìŠ¤íŠ¸ë¥¼ 180ë„ íšŒì „
        ctx.translate(blind.x + blind.width * 0.05, blind.y + blind.height / 2);
        ctx.rotate(-Math.PI/2*3);
      }
    }

    ctx.font = "20px Arial";
    ctx.fillStyle = "red";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, 0, 0); // í˜„ì¬ ê¸°ì¤€ì ì—ì„œ ë Œë”ë§
    ctx.restore(); // ìº”ë²„ìŠ¤ ìƒíƒœ ë³µì›
  });

  blindSpeed += speedIncrement;
}



function triggerInitialFragmentation() {
    const textWidth = 20; // ê°€ìƒì˜ í…ìŠ¤íŠ¸ ë„ˆë¹„
    const textHeight = 10; // ê°€ìƒì˜ í…ìŠ¤íŠ¸ ë†’ì´
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    const fragmentCount = 300; // íŒŒí¸ ê°œìˆ˜
    for (let i = 0; i < fragmentCount; i++) {
        const dx = (Math.random() - 0.5) * 15;
        const dy = (Math.random() - 0.5) * 15;

        fragments.push({
            x: centerX + (i % 6) * (textWidth / 6) - textWidth / 2,
            y: centerY + Math.floor(i / 6) * (textHeight / 4) - textHeight / 2,
            dx,
            dy,
            size: Math.min(textWidth / 2, textHeight / 1),
            opacity: 1,
        });
    }
}







let isClockVisible = false; // ì‹œê³„ê°€ ì²˜ìŒì—ëŠ” ë³´ì´ì§€ ì•ŠìŒ
let hasTriggeredFragmentation = false; // íŒŒí¸í™” íš¨ê³¼ ì‹¤í–‰ ì—¬ë¶€

    function drawTime() {

      if (!isClockVisible) return; // ì‹œê³„ê°€ ë³´ì´ì§€ ì•ŠëŠ” ìƒíƒœì—ì„œëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ

  const now = new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  const milliseconds = String(now.getMilliseconds()).padStart(3, "0");
  const timeText = `${hours}:${minutes}:${seconds}:${milliseconds}`;

  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "white";

  const textWidth = ctx.measureText(timeText).width;
  ctx.fillText(timeText, canvas.width / 2, canvas.height / 2);

  const imageData = ctx.getImageData(
    canvas.width / 2 - textWidth / 2,
    canvas.height / 2 - textSize / 2,
    textWidth,
    textSize
  );

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  blocks = [];
  for (let y = 0; y < imageData.height; y += blockSize) {
    for (let x = 0; x < imageData.width; x += blockSize) {
      const pixelIndex = (y * imageData.width + x) * 4;
      const alpha = imageData.data[pixelIndex + 3];

      if (alpha > 128) {
        const block = {
          x: canvas.width / 2 - textWidth / 2 + x,
          y: canvas.height / 2 - textSize / 2 + y,
          width: blockSize - 1,
          height: blockSize - 1,
        };

        // ë¹„í™œì„±í™”ëœ ì˜ì—­ì¸ì§€ í™•ì¸
        const isDisabled = disabledAreas.some(
          (area) =>
            block.x + block.width > area.x &&
            block.x < area.x + area.width &&
            block.y + block.height > area.y &&
            block.y < area.y + area.height
        );

        if (!isDisabled) {
          blocks.push(block);
        }
      }
    }
  }

  drawBlocks();
}




      

function drawBlocks() {
  if (trailBuffer < maxTrailBuffer) {
    trailBuffer = Math.min(trailBuffer + bufferIncrement, maxTrailBuffer);
  }

  blocks.forEach((block, index) => {
    // ë¹„í™œì„±í™”ëœ ì˜ì—­ì¸ì§€ í™•ì¸
    const isDisabled = disabledAreas.some(
      (area) =>
        block.x + block.width > area.x &&
        block.x < area.x + area.width &&
        block.y + block.height > area.y &&
        block.y < area.y + area.height
    );

    if (isDisabled) return; // ë¹„í™œì„±í™”ëœ ì˜ì—­ì€ ê·¸ë¦¬ì§€ ì•ŠìŒ

    // ë¸”ë¡ì´ ìŠ¤ì™€ì´í”„ ê²½ë¡œì— ìˆëŠ”ì§€ í™•ì¸ (ìŠ¤ì™€ì´í”„ ì¤‘ì¼ ë•Œë§Œ ë°˜ì‘)
    const isInTrail =
      isSwiping &&
      trails.some((trail) => {
        return (
          trail.x + trailBuffer > block.x &&
          trail.x - trailBuffer < block.x + block.width &&
          trail.y + trailBuffer > block.y &&
          trail.y - trailBuffer < block.y + block.height
        );
      });

    if (isInTrail) {
      // ë¸”ë¡ íŒŒí¸í™” ë¡œì§
      const fragmentCount = 8; // ë¸”ë¡ì„ 4ì¡°ê°ìœ¼ë¡œ ë‚˜ëˆ”
      for (let i = 0; i < fragmentCount; i++) {
        const dx = (i % 2 === 0 ? -1 : 1) * Math.random(); // ì¢Œìš°ë¡œ í©ì–´ì§€ëŠ” ë°©í–¥
        const dy = (i < 2 ? -1 : 1) * Math.random(); // ìœ„ì•„ë˜ë¡œ í©ì–´ì§€ëŠ” ë°©í–¥
        const fragmentSize = block.width / 2; // ë¸”ë¡ì„ 4ë“±ë¶„

        fragments.push({
          x: block.x + (i % 2) * fragmentSize, // ì™¼ìª½ ë˜ëŠ” ì˜¤ë¥¸ìª½
          y: block.y + (i < 2 ? 0 : fragmentSize), // ìœ„ìª½ ë˜ëŠ” ì•„ë˜ìª½
          dx: dx * 2, // ì´ˆê¸° ìˆ˜í‰ ì†ë„
          dy: dy * 2, // ì´ˆê¸° ìˆ˜ì§ ì†ë„
          size: fragmentSize,
          opacity: 1,
        });
      }

      // ë¹„í™œì„±í™” ì˜ì—­ ì¶”ê°€
      disabledAreas.push({
        x: block.x,
        y: block.y,
        width: block.width,
        height: block.height,
      });

      blocks.splice(index, 1); // ë¸”ë¡ ì œê±°
    } else {
      ctx.fillStyle = "white";
      ctx.fillRect(block.x, block.y, block.width, block.height);
    }
  });

  // íŒŒí¸ ë Œë”ë§ ë° ì—…ë°ì´íŠ¸
  drawFragments();
}







let settledFragments = []; // ë°”ë‹¥ì— ìŒ“ì¸ íŒŒí¸ ì €ì¥

function drawFragments() {
  const gravity = 0.5; // ì¤‘ë ¥ íš¨ê³¼
  const friction = 0.9; // ë°”ë‹¥ì—ì„œì˜ ë§ˆì°°ë ¥
  const collisionPadding = 0.5; // ì¶©ëŒ ì—¬ìœ  ê³µê°„
  const initialSpread = 50; // ì´ˆê¸° í¼ì§ ë²”ìœ„

  fragments.forEach((fragment, index) => {

     // ì²˜ìŒì— ê°•ë ¬í•œ í¼ì§ íš¨ê³¼ ì¶”ê°€
    if (!fragment.initialized) {
      const angle = Math.random() * Math.PI * 2; // ëœë¤ ë°©í–¥ (360ë„)
      const spreadDistance = Math.random() * initialSpread; // ì´ˆê¸° í¼ì§ ê±°ë¦¬

      // ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ì ì—ì„œ í¼ì§€ê²Œ ì„¤ì •
      fragment.x += Math.cos(angle) * spreadDistance;
      fragment.y += Math.sin(angle) * spreadDistance;

      // ì´ˆê¸° ì†ë„ë¥¼ í¼ì§ ë°©í–¥ìœ¼ë¡œ ì„¤ì •
      const burstSpeed = 10; // ì´ˆê¸° ì†ë„ ê³„ìˆ˜
      fragment.dx += Math.cos(angle) * burstSpeed;
      fragment.dy += Math.sin(angle) * burstSpeed;

      fragment.initialized = true; // ì´ˆê¸°í™” ìƒíƒœ í”Œë˜ê·¸ ì„¤ì •
    }

    // íŒŒí¸ ìƒ‰ìƒ ê³„ì‚° (í°ìƒ‰ -> ë¹¨ê°„ìƒ‰)
    fragment.colorStep = fragment.colorStep || 0; // ì´ˆê¸° ìƒ‰ìƒ ë‹¨ê³„
    const red = Math.round(255); // ë¹¨ê°„ìƒ‰
    const green = Math.round(255 - fragment.colorStep * 255); // ì´ˆë¡ìƒ‰ ê°ì†Œ
    const blue = Math.round(255 - fragment.colorStep * 255); // íŒŒë€ìƒ‰ ê°ì†Œ
    const color = `rgba(${red}, ${green}, ${blue}, ${fragment.opacity})`; // íˆ¬ëª…ë„ ë°˜ì˜



    // íŒŒí¸ ë Œë”ë§
     if (fragment.imageFragment) {
            const { imgElement, sx, sy, sWidth, sHeight } = fragment.imageFragment;
            ctx.drawImage(
                imgElement,
                sx,
                sy,
                sWidth,
                sHeight,
                fragment.x,
                fragment.y,
                fragment.size,
                fragment.size
            );
        } else {
            ctx.fillStyle = 'rgba(255, 255, 255, ' + fragment.opacity + ')';
            ctx.fillRect(fragment.x, fragment.y, fragment.size, fragment.size);
        }

    // ì¤‘ë ¥ ì ìš©
    fragment.dy += gravity;

    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    fragment.x += fragment.dx;
    fragment.y += fragment.dy;

    // ë°”ë‹¥ ë˜ëŠ” ë‹¤ë¥¸ íŒŒí¸ê³¼ ì¶©ëŒ ì²˜ë¦¬
    let isCollidingWithGround = fragment.y + fragment.size >= canvas.height;
    let isCollidingWithSettled = false;

    for (const settled of settledFragments) {
      if (
        fragment.x + fragment.size > settled.x - collisionPadding &&
        fragment.x < settled.x + settled.size + collisionPadding &&
        fragment.y + fragment.size >= settled.y &&
        fragment.y <= settled.y + settled.size
      ) {
        isCollidingWithSettled = true;
        fragment.y = settled.y - fragment.size; // ìœ„ì— ìŒ“ì´ë„ë¡ ìœ„ì¹˜ ì¡°ì •
        break;
      }
    }

    if (isCollidingWithGround || isCollidingWithSettled) {
        fragment.dy = 0; // ìˆ˜ì§ ì†ë„ ì œê±°
        fragment.dx = 0; // ìˆ˜í‰ ì†ë„ ì œê±°
        fragment.isSettling = true; // ê³ ì • ìƒíƒœ í™œì„±í™”

        if (fragment.isSettling) {
            // 2ì´ˆ ë™ì•ˆ íˆ¬ëª…ë„ë¥¼ ì¤„ì´ë©° ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë³€í™˜
            fragment.settleTimer = fragment.settleTimer || Date.now(); // íƒ€ì´ë¨¸ ì‹œì‘
            const elapsedTime = (Date.now() - fragment.settleTimer) / 2000; // 2ì´ˆ ê¸°ì¤€

            fragment.opacity = 1 - Math.min(elapsedTime, 1); // íˆ¬ëª…ë„ ê°ì†Œ (1 -> 0)
            fragment.colorStep = Math.min(elapsedTime, 1); // ìƒ‰ìƒ ë³€í™” ë‹¨ê³„ (0 -> 1)

            // íˆ¬ëª…ë„ê°€ ê°ì†Œí•˜ë©° ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì ì§„ì ìœ¼ë¡œ ë³€í•¨
            if (fragment.colorStep >= 1 && fragment.opacity <= 0) {
                settledFragments.push({
                    x: fragment.x,
                    y: fragment.y,
                    size: fragment.size,
                    dy: 0.3, // ì•„ë˜ë¡œ ë‚´ë ¤ê°€ëŠ” ì´ˆê¸° ì†ë„
                });
                fragments.splice(index, 1); // ì´ë™ ì¤‘ì¸ íŒŒí¸ ì œê±°
            }

        }
    }



    
  });

  // ê³ ì •ëœ íŒŒí¸ ì´ë™ ë° ë Œë”ë§
  settledFragments.forEach((settled, index) => {
      // íŒŒí¸ ì´ë™
      settled.y += settled.dy; // ì•„ë˜ë¡œ ì´ë™


      // í™”ë©´ ì•„ë˜ë¡œ ì™„ì „íˆ ì‚¬ë¼ì§€ë©´ ì œê±°
      if (settled.y > canvas.height) {
          settledFragments.splice(index, 1); // í™”ë©´ì—ì„œ ì œê±°
      }

      // íŒŒí¸ ë Œë”ë§
      ctx.fillStyle = 'red'; // ê³ ì •ëœ ì¡°ê°ì€ ë¹¨ê°„ìƒ‰
      ctx.fillRect(settled.x, settled.y, settled.size, settled.size);
  });

}










        function recoverDisabledAreas() {
          setInterval(() => {
            if (disabledAreas.length > 0) {
              // ê°€ì¥ ì˜¤ë˜ëœ ë¹„í™œì„±í™”ëœ ì˜ì—­ì„ ì œê±°
              disabledAreas.shift();
            }
          }, 250); // 5ì´ˆë§ˆë‹¤ ë³µêµ¬
        }

        // ë³µêµ¬ í•¨ìˆ˜ ì‹¤í–‰
        recoverDisabledAreas();




        function drawTrails() {
          if (trails.length < 2) return;

          ctx.lineCap = 'round';
          for (let i = trails.length - 1; i > 0; i--) {
            const trailStart = trails[i];
            const trailEnd = trails[i - 1];
            const opacity = trailStart.opacity;

            if (opacity <= 0) continue;

            ctx.beginPath();
            ctx.lineWidth = Math.max(10 - (trails.length - i) * 1, 2);
            ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`; // ë¹¨ê°„ìƒ‰ ê¼¬ë¦¬
            ctx.moveTo(trailStart.x, trailStart.y);
            ctx.lineTo(trailEnd.x, trailEnd.y);
            ctx.stroke();
            ctx.closePath();
          }

          trails = trails.filter(trail => trail.opacity > 0);
        }

        canvas.addEventListener('mousemove', (event) => {
          const mouseX = event.clientX;
          const mouseY = event.clientY;

          trails.push({ x: mouseX, y: mouseY, opacity: 1 });

          if (trails.length > 10) {
            trails.shift();
          }
        });


        // ìŠ¤ì™€ì´í”„ ì´ë²¤íŠ¸ í•¸ë“¤ë§
canvas.addEventListener('mousedown', (event) => {
  const swipeStart = { x: event.clientX, y: event.clientY, time: Date.now() };
  isSwiping = true;
  let isDragging = true;
  let velocityX = 0;
  let velocityY = 0;



  const dragFactor = 0.25; // ì†ê°€ë½ì„ ë”°ë¼ì˜¤ëŠ” ê°ì‡  ê³„ìˆ˜
  const momentumFactor = 1.5; // ëª¨ë©˜í…€ ì´ë™ ê°€ì† ê³„ìˆ˜

  canvas.addEventListener(
    'mousemove',
    (e) => {
      if (!isDragging) return;

      const swipeCurrent = { x: e.clientX, y: e.clientY, time: Date.now() };
      const dx = (swipeCurrent.x - swipeStart.x) * dragFactor;
      const dy = (swipeCurrent.y - swipeStart.y) * dragFactor;

      const elapsedTime = (swipeCurrent.time - swipeStart.time) / 1000; // ì´ˆ ë‹¨ìœ„ ì‹œê°„ ì°¨ì´
      velocityX = dx / elapsedTime; // xì¶• ì†ë„ ê³„ì‚°
      velocityY = dy / elapsedTime; // yì¶• ì†ë„ ê³„ì‚°

      blinds.forEach((blind) => {
        if (blind.type === "vertical") {
          blind.y += dy; // ìƒí•˜ë¡œ ë¶€ë“œëŸ½ê²Œ ëŒë¦¼
        } else if (blind.type === "horizontal") {
          blind.x += dx; // ì¢Œìš°ë¡œ ë¶€ë“œëŸ½ê²Œ ëŒë¦¼
        }
      });

      // ë‹¤ìŒ ì´ë™ì„ ìœ„í•´ ì‹œì‘ì  ê°±ì‹ 
      swipeStart.x = swipeCurrent.x;
      swipeStart.y = swipeCurrent.y;
      swipeStart.time = swipeCurrent.time;
    },
    { passive: true }
  );

  canvas.addEventListener(
    'mouseup',
    () => {
      isDragging = false;

      blinds.forEach((blind) => {
        // ëª¨ë©˜í…€ ì´ë™ ì ìš©
        if (blind.type === "vertical") {
          const destinationY =
            blind.y + velocityY * momentumFactor; // ëª¨ë©˜í…€ ê¸°ë°˜ ìµœì¢… ìœ„ì¹˜
          animateBlind(blind, "y", destinationY); // ìƒí•˜ ì• ë‹ˆë©”ì´ì…˜
        } else if (blind.type === "horizontal") {
          const destinationX =
            blind.x + velocityX * momentumFactor; // ëª¨ë©˜í…€ ê¸°ë°˜ ìµœì¢… ìœ„ì¹˜
          animateBlind(blind, "x", destinationX); // ì¢Œìš° ì• ë‹ˆë©”ì´ì…˜
        }
      });

      isSwiping = false; // ìŠ¤ì™€ì´í”„ ì¢…ë£Œ
      trails = []; // ìŠ¤ì™€ì´í”„ ê²½ë¡œ ì´ˆê¸°í™”
    },
    { once: true }
  );
});

// ë¸”ë¼ì¸ë“œ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
function animateBlind(blind, axis, destination) {
  const animationSpeed = 0.05; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„ ê³„ìˆ˜
  const animationFrame = () => {
    // í˜„ì¬ ìœ„ì¹˜ì™€ ëª©ì ì§€ ì°¨ì´ ê³„ì‚°
    const distance = destination - blind[axis];
    const step = distance * animationSpeed;

    if (Math.abs(step) > 1) {
      blind[axis] += step; // ë¶€ë“œëŸ½ê²Œ ì´ë™
      requestAnimationFrame(animationFrame); // ë‹¤ìŒ í”„ë ˆì„ í˜¸ì¶œ
    } else {
      blind[axis] = destination; // ëª©ì ì§€ì— ê³ ì •
    }
  };

  requestAnimationFrame(animationFrame);
}











let inactivityTimer = null; // ë¹„í™œë™ íƒ€ì´ë¨¸
let isInactive = false; // ë¹„í™œë™ ìƒíƒœ ì—¬ë¶€
let recoveryIndex = 0; // ë³µêµ¬í•  ì‹œê°„ ë¸”ë¡ì˜ ì¸ë±ìŠ¤
let isRecovering = false; // ë³µêµ¬ ì¤‘ ìƒíƒœ

// ë¹„í™œë™ íƒ€ì´ë¨¸ ì´ˆê¸°í™”
function resetInactivityTimer() {
  if (isInactive || isRecovering) return;

  clearTimeout(inactivityTimer);
  inactivityTimer = setTimeout(() => {
    isInactive = true;
    recoverBlocksAndFragments();
  }, 10000000000000); // 10ì´ˆ
}

// íŒŒí¸ê³¼ ë¸”ë¡ì„ ë³µêµ¬í•˜ëŠ” í•¨ìˆ˜
function recoverBlocksAndFragments() {
  if (isRecovering) return;

  isRecovering = true;
  const recoveryInterval = setInterval(() => {
    // íŒŒí¸ ì„œì„œíˆ ì œê±°
    if (fragments.length > 0) {
      fragments.pop(); // ë§ˆì§€ë§‰ íŒŒí¸ë¶€í„° í•˜ë‚˜ì”© ì œê±°
    }

    // ì‹œê°„ ë¸”ë¡ ë³µêµ¬
    if (recoveryIndex < disabledAreas.length) {
      const area = disabledAreas[recoveryIndex];
      blocks.push({
        x: area.x,
        y: area.y,
        width: area.width,
        height: area.height,
      });
      recoveryIndex++;
    }

    // ì‘ì—… ì™„ë£Œ ì¡°ê±´ í™•ì¸
    if (fragments.length === 0 && recoveryIndex >= disabledAreas.length) {
      clearInterval(recoveryInterval); // ë³µêµ¬ ì¢…ë£Œ
      disabledAreas = []; // ë¹„í™œì„±í™”ëœ ì˜ì—­ ì´ˆê¸°í™”
      recoveryIndex = 0; // ë³µêµ¬ ì¸ë±ìŠ¤ ì´ˆê¸°í™”
      isRecovering = false; // ë³µêµ¬ ì¤‘ ìƒíƒœ í•´ì œ
      location.reload(); // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
    }
  }, 100); // 0.1ì´ˆ ê°„ê²©ìœ¼ë¡œ ë³µêµ¬
}

// ì‚¬ìš©ì ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ë¹„í™œë™ íƒ€ì´ë¨¸ ì´ˆê¸°í™”
["mousemove", "mousedown", "touchstart"].forEach((event) => {
  document.addEventListener(event, () => {
    resetInactivityTimer();
    isInactive = false;
  });
});

// ì´ˆê¸° íƒ€ì´ë¨¸ ì„¤ì •
resetInactivityTimer();

// ì—…ë°ì´íŠ¸ í•¨ìˆ˜ì—ì„œ ë³µêµ¬ ìƒíƒœ í™•ì¸
function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!isRecovering) {
    drawTime();
    updateBlinds();
    drawTrails();
  }
  requestAnimationFrame(update);
}

update();


    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });


    
  </script>
</body>
</html>
